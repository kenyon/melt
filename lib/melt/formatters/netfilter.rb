module Melt
  module Formatters
    # Netfilter implementation of a Melt formatter.
    class Netfilter < Base # :nodoc:
      # Returns a Netfilter String representation of the provided +rule+ Melt::Rule.
      def emit_rule(rule)
        if rule.nat?
          emit_postrouting_rule(rule)
        elsif rule.rdr?
          emit_prerouting_rule(rule)
        else
          emit_filter_rule(rule)
        end
      end

      # Returns a Netfilter String representation of the provided +rules+ Array of Melt::Rule with the +policy+ policy.
      def emit_ruleset(rules, policy = :block)
        parts = []
        parts << "# Generated by melt v#{Melt::VERSION} on #{Time.now.strftime('%c')}"
        parts << nat_ruleset(nat_rules(rules))
        parts << filter_ruleset(filter_rules(rules), policy)
        parts.flatten.compact.join("\n") + "\n"
      end

      protected

      def nat_ruleset(rules)
        return unless rules.any?

        parts = ['*nat']
        parts << emit_chain_policies(prerouting: :pass, input: :pass, output: :pass, postrouting: :pass)
        parts << rules.select(&:rdr?).map { |rule| emit_rule(rule) }
        parts << rules.select(&:nat?).map { |rule| emit_rule(rule) }
        parts << 'COMMIT'
        parts
      end

      def filter_ruleset(rules, policy)
        return unless rules.any?

        parts = ['*filter']
        parts << emit_chain_policies(input: policy, forward: policy, output: policy)
        parts << input_filter_ruleset(rules)
        parts << forward_filter_ruleset(rules)
        parts << output_filter_rulset(rules)
        parts << 'COMMIT'
        parts
      end

      def emit_chain_policies(policies)
        policies.map { |chain, action| ":#{chain.upcase} #{iptables_action(action)} [0:0]" }
      end

      def input_filter_ruleset(rules)
        parts = ['-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT']
        parts << input_filter_rules(rules).map { |rule| emit_rule(rule) }
      end

      def forward_filter_ruleset(rules)
        parts = ['-A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT']
        parts << rules.select(&:fwd?).map { |rule| emit_rule(rule) }
        parts << rules.select { |r| r.rdr? && !@loopback_addresses.include?(r.rdr_to_host) }.map { |rule| emit_rule(rule.as_fwd_rule) }
      end

      def output_filter_rulset(rules)
        parts = ['-A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT']
        parts << output_filter_rules(rules).map { |rule| emit_rule(rule) }
      end

      def emit_postrouting_rule(rule)
        "-A POSTROUTING -o #{rule.on} -j MASQUERADE"
      end

      def emit_prerouting_rule(rule)
        parts = ['-A PREROUTING']
        parts << emit_on(rule)
        parts << emit_proto(rule)
        parts << emit_src(rule)
        parts << emit_dst(rule)
        parts << emit_redirect_or_dnat(rule)
        pp_rule(parts)
      end

      def emit_filter_rule(rule)
        iptables_direction = { in: 'INPUT', out: 'OUTPUT', fwd: 'FORWARD' }
        parts = ["-A #{iptables_direction[rule.dir]}"]
        parts << emit_if(rule)
        parts << emit_proto(rule)
        parts << emit_src(rule)
        parts << emit_dst(rule)
        parts << emit_jump(rule)
        pp_rule(parts)
      end

      def emit_if(rule)
        if rule.on
          emit_on(rule)
        else
          emit_in_out(rule)
        end
      end

      def emit_on(rule)
        on_direction_flag = { in: '-i', out: '-o' }

        if rule.on && rule.dir
          matches = /(!)?(.*)/.match(rule.on)
          [matches[1], on_direction_flag[rule.dir], matches[2]].compact
        end
      end

      def emit_in_out(rule)
        parts = []
        parts << "-i #{rule.in}" if rule.in
        parts << "-o #{rule.out}" if rule.out
        parts
      end

      def emit_proto(rule)
        "-p #{rule.proto}" if rule.proto
      end

      def emit_src(rule)
        emit_endpoint_specification(:in, rule.src_host, rule.src_port)
      end

      def emit_dst(rule)
        emit_endpoint_specification(:out, rule.dst_host, rule.dst_port)
      end

      def emit_endpoint_specification(direction, host, port)
        flag = { in: 's', out: 'd' }[direction]
        parts = []
        parts << "-#{flag} #{emit_address(host)}" if host
        parts << "--#{flag}port #{port}" if port
        parts
      end

      def emit_redirect_or_dnat(rule)
        if @loopback_addresses.include?(rule.rdr_to_host)
          emit_redirect(rule)
        else
          emit_dnat(rule)
        end
      end

      def emit_redirect(rule)
        "-j REDIRECT --to-port #{rule.rdr_to_port}"
      end

      def emit_dnat(rule)
        "-j DNAT --to-destination #{rule.rdr_to_host}"
      end

      def emit_jump(rule)
        "-j #{iptables_action(rule)}"
      end

      private

      def nat_rules(rules)
        rules.select { |r| r.nat? || r.rdr? }
      end

      def filter_rules(rules)
        rules.select { |r| [:pass, :block, :log].include?(r.action) }
      end

      def input_filter_rules(rules)
        rules.select { |r| r.filter? && r.in? }
      end

      def output_filter_rules(rules)
        rules.select { |r| r.filter? && r.out? }
      end

      def pp_rule(parts)
        parts.flatten.compact.join(' ')
      end

      def iptables_action(rule_or_action, ret = false)
        case rule_or_action
        when :pass then 'ACCEPT'
        when :log then 'LOG'
        when :block then
          ret ? 'RETURN' : 'DROP'
        when Rule then iptables_action(rule_or_action.action, rule_or_action.return)
        end
      end
    end
  end
end
